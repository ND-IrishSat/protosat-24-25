# -- coding: utf-8 --
"""IrishSat_modeling_example.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KSRKoBOB1ciqBtUFawmjS5yrVvqBeWx-
"""

# Tutorial on how to model a simple 1D spring damper system
# Authors: Patrick Schwartz, Andrew Gaylord
# 9/13/24
# IrishSat

import numpy as np
import matplotlib.pyplot as plt
import random

# initial conditions
# x refers to our state (what we want to keep track of)
# in this case, it is position and velocity of spring on 1 axis
# this means that our cube starts at 10 horizontal distance and 4 velocity
x0 = np.array([10, 4])
print("Initial position on x axis: {}".format(x0[0]))
print("Initial velocity: {}".format(x0[1]))

# =================================================================
# set up equations of motion

# final time
tf = 10
# time step
dt = .01
# number of time slices
n = int(tf/dt)
print("Looking at {} slices over {} seconds".format(n, tf))

# mass (kg)
m = 10
# spring constant (N/m)
k = 100
# random physics parameter (N*s/m)
b = 10

# our matrices that define our state space
#     these pieces of our * "equations of motion" (EOMs) * dictate how our spring should behave
# remeber how Patrick derived an equation in the form
#   A*x + B*u
# where x is our state and u is our input (force applied to the spring)
# this equation comes from applying Newton's second law to our forces (friction, applied force, etc)
A = np.array([[0, 1], [-k/m, -b/m]])
B = np.array([0, 1])

# =================================================================
# initializing axis and inputs

# time array (x axis for graph)
# we want to know our state at each time step
# our speed and velocity at t=0, t=0.01, t=0.02, etc
t = np.linspace(0, tf, n)

# x is a 2D array that represents our state at each time step
x = np.zeros((n, 2))
# we know that our state at t=0 is x0
x[0] = x0

# this is our force input for every time step
# for this example, we say it is constant (always pulling with F=1)
F = np.array([1]*n)

def fc(x, u):
  # continuous-time function
  # This sets up the system of 1st order ordinary differential equations (ODE's)
  # to describe the motion of the system in continuous time
  # x_dot = Ax + Bu (Patrick derived this on the board)
  return np.matmul(A, x) + B*u

def fd(x, u, dt):
  # discrete-time function
  # returns the Euler approximation of our state dt seconds after x
  return fc(x, u) * dt + x



# =================================================================
# Euler's method to calculate state for every discrete time

for i in range(n-1):
  # populate our x array using our physics model
  # approximate state at next time step based on current state
  
  x[i+1] = fd(x[i], F[i+1], dt)
  


y=np.copy(x)

for i in range(n-1):
  randnum = random.uniform(-1,1)
  x[i+1,0] = x[i+1,0] + randnum
  
predicted_values = []
corrected_values = []

# Initial state and uncertainty
initial_state = x[0, 0]  # Set your initial guess for the state
initial_uncertainty = 1  # Set your initial uncertainty
current_estimate = initial_state  # This will hold the current estimate
P = initial_uncertainty  # This will hold the current uncertainty

# Process and measurement noise variances
Q = 0.9 # Set your process noise variance
R = 10 # Set your measurement noise variance

for z in x[:, 0]:  # Loop through the measurements in x (only the position part)
    # Prediction step
    x_pred = current_estimate  # Predicted state (assuming no dynamic change)
    P_pred = P + Q  # Predicted uncertainty
    predicted_values.append(x_pred)  # Append the scalar predicted value
    
    # Calculate Kalman Gain
    K = P_pred / (P_pred + R)
    
    # Correction step
    current_estimate = x_pred + K * (z - x_pred)  # Updated state estimate
    P = (1 - K) * P_pred  # Updated uncertainty
    corrected_values.append(current_estimate)  # Append the scalar corrected value

# =================================================================
# graphing our results

fig, axs = plt.subplots(3, 1, layout='constrained')
fig.suptitle("Spring Damper System")

axs[0].plot(t, x[:, 0])  # Position from x array
axs[0].set_xlabel("Time")
axs[0].set_ylabel("Position (m)")

axs[1].plot(t, y[:, 0])  # Real Position from y array
axs[1].set_xlabel("Time")
axs[1].set_ylabel("Real Position (m/s)")

axs[2].plot(t, corrected_values)  # Corrected Position (using scalar values directly)
axs[2].set_xlabel("Time")
axs[2].set_ylabel("Corrected Position (m/s)")

plt.show()